<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="=_=">
  <meta name="keywords" content="">
  
    <link rel="icon" href="/images/favicon.ico">
  
    
  <title>ACM思考题-1 | Xiaoru&#39;s Website</title>
  <link rel="stylesheet" href="/style.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.1.20/jquery.fancybox.min.css" />
</head>

<body>
  <header>
  <div class="header-container">
    <a class='logo' href="/">
      <span>Xiaoru's Website</span>
    </a>
    <ul class="right-header">
      
        <li class="nav-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/movies" class="item-link">Movies</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/archives" class="item-link">Archives</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/tags" class="item-link">Tags</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/about" class="item-link">About</a>
          
        </li>
      
    </ul>
  </div>
</header>

  <main id='post'>
  <div class="content">
    <article>
        <section class="content markdown-body">
          <h1>ACM思考题-1</h1>
          <div class='post-meta'>
            <i class="fa fa-calendar" aria-hidden="true"></i> <time>2018年02月18日</time>
            
              | <i class="fa fa-folder-open-o" aria-hidden="true"></i> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Computer-Science/">Computer Science</a>
  </div>



            
            
              | 
                  <i class="fa fa-tags" aria-hidden="true"></i>
                
               
  <a href="/tags/#Algorithm" class='tag'>Algorithm</a>

  <a href="/tags/#Data Structure" class='tag'>Data Structure</a>


            
          </div>
          <script src="/assets/js/APlayer.min.js"> </script><h3 id="思考题-The-Perfect-Stall"><a href="#思考题-The-Perfect-Stall" class="headerlink" title="思考题-The Perfect Stall"></a><strong><em>思考题-The Perfect Stall</em></strong></h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>Farmer John completed his new barn just last week, complete with all the latest milking technology. Unfortunately, due to engineering problems, all the stalls in the new barn are different. For the first week, Farmer John randomly assigned cows to stalls, but it quickly became clear that any given cow was only willing to produce milk in certain stalls. For the last week, Farmer John has been collecting data on which cows are willing to produce milk in which stalls. A stall may be only assigned to one cow, and, of course, a cow may be only assigned to one stall.<br>Given the preferences of the cows, compute the maximum number of milk-producing assignments of cows to stalls that is possible. </p>
<p>The input includes several cases. For each case, the first line contains two integers, N (0 &lt;= N &lt;= 200) and M (0 &lt;= M &lt;= 200). N is the number of cows that Farmer John has and M is the number of stalls in the new barn. Each of the following N lines corresponds to a single cow. The first integer (Si) on the line is the number of stalls that the cow is willing to produce milk in (0 &lt;= Si &lt;= M). The subsequent Si integers on that line are the stalls in which that cow is willing to produce milk. The stall numbers will be integers in the range (1..M), and no stall will be listed twice for a given cow.</p>
<p>For each case, output a single line with a single integer, the maximum number of milk-producing stall assignments that can be made.</p>
</blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><blockquote><p>本题应该采用匈牙利算法，核心就是寻找增广路径，即用增广路径求二分图最大匹配的算法。其基本思路为在输入数据的过程中将奶牛与其喜欢的stall所构成的边以对象edge的形式存入e数组，fst[i]表示的是第i头牛所喜欢stalls的初始编号，后可根据nxt推算。srch函数为核心代码，其原则是“有机会就匹配，没机会创造机会也要匹配”，首先根据牛的编号idx找到其喜欢stalls的第一个位置，如果第一个位置没有被标记过则暂时标为真，再通过rst_arr判断该位置是否被其他奶牛先占领，如果没有占领或者通过递归调用(true表示能够腾出位置，即通过dfs找增广路径)，则将这个stall标记为该奶牛的编号，并返回真，其他情况则返回假，说明该奶牛找不到匹配的stall。主程序中需要每次对标记数组清零(false)，再对奶牛进行匹配，如果返回true则成功匹配数量+1。</p>
</blockquote>
<h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><blockquote><p>本题图构造的数据结构采用的是邻接表形式，通过分析，如果二分图的左半边一共有n个点，最多找n条增广路径，如果图中有m条边，每一条增广路径把所有边遍历一遍，所以时间复杂度为O(nm)。</p>
</blockquote>
<h4 id="源代码-CPP"><a href="#源代码-CPP" class="headerlink" title="源代码(CPP)"></a>源代码(CPP)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fst[<span class="number">210</span>], ln, rst_arr[<span class="number">210</span>], N, M, Si, item; <span class="keyword">bool</span> vstd[<span class="number">210</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> pnt, nxt;</span><br><span class="line">&#125;;</span><br><span class="line">edge e[<span class="number">4040</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">srch</span><span class="params">(<span class="keyword">int</span> idx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M)</span><br><span class="line">    &#123;</span><br><span class="line">        ln = <span class="number">0</span>; <span class="keyword">int</span> rst = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">210</span>; ++i) &#123; fst[i] = <span class="number">-1</span>; rst_arr[i] = <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; Si;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Si; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; item;</span><br><span class="line">                e[ln].pnt = item; e[ln].nxt = fst[i];</span><br><span class="line">                fst[i] = ln++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">210</span>; ++j) vstd[j] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(srch(i)) ++rst;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; rst &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">srch</span><span class="params">(<span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = fst[idx];</span><br><span class="line">    <span class="keyword">while</span>(i != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id = e[i].pnt;</span><br><span class="line">        <span class="keyword">if</span>(vstd[id] == <span class="literal">false</span>)&#123;</span><br><span class="line">            vstd[id] = <span class="literal">true</span>; <span class="keyword">bool</span> judg;</span><br><span class="line">            judg = rst_arr[id]==<span class="number">0</span> || srch(rst_arr[id]);</span><br><span class="line">            <span class="keyword">if</span>(judg) &#123; rst_arr[id]=idx; <span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i = e[i].nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="思考题-蚂蚁相撞"><a href="#思考题-蚂蚁相撞" class="headerlink" title="思考题-蚂蚁相撞"></a><strong><em>思考题-蚂蚁相撞</em></strong></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><img src="/2018/02/18/blog4/blog4-1.png" title="[blog4-img1]">
<h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><blockquote><p>这道思考题诀窍是首先蚂蚁相撞过后看起来是各自行走方向相反，实则可以看作方向不变，即朝右的蚂蚁继续朝右，朝左的蚂蚁继续朝左运动，因为只需记录相碰的位置和终态位置方向不涉及到碰撞方向；其次是蚂蚁在水平杆上的相对顺序位置不变。利用以上两点，可以只采用pre、thn数组表示蚂蚁的初态和终态(不用考虑期间蚂蚁相碰后改变方向)，pre、thn数组数据存入和计算后分别按照水平杆的位置从小到大进行排序(这时改变了输入的顺序，且蚂蚁运动前后相对位置不变，可以公用数组下标)，但为了保证输出的顺序和输入的顺序一致，采用seq数组建立输入顺序和位置顺序的映射(seq[i]表示第“i”个输入的蚂蚁的位置顺序编号)。同时采用pst数组记录碰撞位置用于输出时的判断。由于最开始的pst数组是采用vector容器记录，但总是WA，后来发现是因为vector记录碰撞位置的下标是以水平杆的位置排列，而不是输入顺序，所以只能牺牲空间来建立pst数组记录碰撞位置，输出时以pst[seq[i]]来表示第i只蚂蚁的碰撞位置。</p>
</blockquote>
<h4 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><blockquote><p>此题每一个case的时间复杂度应该是以sort函数的复杂度O(n*logn)确定，因为其他语句块的复杂度都是线性O(n)。</p>
</blockquote>
<h4 id="源代码-CPP-1"><a href="#源代码-CPP-1" class="headerlink" title="源代码(CPP)"></a>源代码(CPP)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ant</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> idx, p, d;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> ant&amp; a) <span class="keyword">const</span> &#123; <span class="keyword">return</span> p &lt; a.p;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ant pre[<span class="number">10005</span>], thn[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> seq[<span class="number">10005</span>], N, L, T, n, pst_;</span><br><span class="line"><span class="keyword">char</span> orient[][<span class="number">20</span>] = &#123;<span class="string">"L"</span>,<span class="string">"Turning"</span>,<span class="string">"R"</span>&#125;;</span><br><span class="line"><span class="comment">//vector&lt;int&gt; pst(0);</span></span><br><span class="line"><span class="keyword">int</span> pst[<span class="number">10005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N); <span class="comment">//scanf("%d", &amp;);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"case #%d:\n"</span>, i);</span><br><span class="line">input();</span><br><span class="line">        sort(pre, pre + n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) seq[pre[i].idx] = i; <span class="comment">//建立输入和初始位置的映射</span></span><br><span class="line">        sort(thn, thn + n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> judg; judg = thn[i].p == thn[i+<span class="number">1</span>].p;</span><br><span class="line">            <span class="keyword">if</span>(judg) <span class="comment">//相撞</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//pst_ = thn[i].p;</span></span><br><span class="line">                <span class="comment">//pst.push_back(thn[i].p);</span></span><br><span class="line">                pst[i] = thn[i].p; pst[i+<span class="number">1</span>] = thn[i+<span class="number">1</span>].p; <span class="comment">//存入撞位置</span></span><br><span class="line">                thn[i].p = thn[i+<span class="number">1</span>].p = <span class="number">0</span>;<span class="comment">//相撞点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//seq[i]表示第“i”输入的蚂蚁的相对位置排序编号</span></span><br><span class="line">            <span class="keyword">bool</span> judg; judg = thn[seq[i]].p &lt; <span class="number">0</span> || thn[seq[i]].p &gt; L;</span><br><span class="line">            <span class="keyword">if</span>(judg) <span class="built_in">printf</span>(<span class="string">"Fell off\n"</span>);</span><br><span class="line">            <span class="comment">//else if(thn[seq[i]].p == 0) printf("%d Turning\n", pst_);</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(thn[seq[i]].p == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d Turning\n"</span>, pst[seq[i]]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = thn[seq[i]].p;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %s\n"</span>, tmp, orient[thn[seq[i]].d+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;L, &amp;T, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> loc, ort; <span class="keyword">char</span> dir;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %c"</span>, &amp;loc, &amp;dir);</span><br><span class="line"> 		<span class="comment">//ort为运动方向，左-1，右1</span></span><br><span class="line">		<span class="keyword">if</span>(dir == ‘L’) ort = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> ort = <span class="number">1</span>;</span><br><span class="line">        pre[i].idx= i; pre[i].p = loc; pre[i].d = ort;</span><br><span class="line">        thn[i].idx = <span class="number">0</span>; thn[i].p = loc + T * ort; thn[i].d = ort;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>正文结束，如需转载，请标明出处！</em></strong></p>
<hr>

        </section>
    </article>
    
    
        <!-- livere 评论框 start -->
        <div class="comment">
            <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzgyNi8xMDM3OQ=="></div>
        </div>
        <!-- livere 评论框 end -->
    
  </div>
  <aside>
    
    <div class="toc-container">
        <h1>目录</h1>
        <div class="content">
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#思考题-The-Perfect-Stall"><span class="toc-number">1.</span> <span class="toc-text">思考题-The Perfect Stall</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#题目"><span class="toc-number">1.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解题思路"><span class="toc-number">1.2.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#时间复杂度分析"><span class="toc-number">1.3.</span> <span class="toc-text">时间复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#源代码-CPP"><span class="toc-number">1.4.</span> <span class="toc-text">源代码(CPP)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#思考题-蚂蚁相撞"><span class="toc-number">2.</span> <span class="toc-text">思考题-蚂蚁相撞</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#题目-1"><span class="toc-number">2.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解题思路-1"><span class="toc-number">2.2.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#时间复杂度分析-1"><span class="toc-number">2.3.</span> <span class="toc-text">时间复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#源代码-CPP-1"><span class="toc-number">2.4.</span> <span class="toc-text">源代码(CPP)</span></a></li></ol></li></ol>
        </div>
    </div>
    
  </aside>
</main>


<script type="text/javascript">
  (function(d, s) {
      var j, e = d.getElementsByTagName(s)[0];

      if (typeof LivereTower === 'function') { return; }

      j = d.createElement(s);
      j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
      j.async = true;

      e.parentNode.insertBefore(j, e);
  })(document, 'script');
</script>


  <footer>
  <div class="copyright">
    <div>
      &copy; 2018 | Xiaoru Zhu<!--Powered by <a href="https://hexo.io" target="_blank">Hexo</a>-->&nbsp
    </div>
    <!--
    <div>
      Theme by <a href="https://github.com/lewis-geek/hexo-theme-Aath" target="_blank">Aath</a>
    </div>
    -->
  </div>
</footer>


<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script src="/lib/in-view.min.js"></script>
<script src="/lib/lodash.min.js"></script>
<script>
  var isDown = true
  var oldY = 0
  inView.offset(50)

  document.body.addEventListener('touchstart', function(){});

  window.addEventListener('scroll', _.throttle(e => {
    var currentY = window.scrollY
    if((oldY - currentY) < 0) {
      isDown = true
    } else {
      isDown = false
    }
    oldY = currentY
  }, 250))

  $("article img").each(function() {
      var strA = "<a data-fancybox='gallery' href='" + this.src + "'></a>";
      $(this).wrapAll(strA);
  });

  $('.toc-link').each(function() {
      var href = $(this).attr("href");

      inView(href).on('exit', () => {
        if (isDown) {
          handleActive(href)
        }
      })

      inView(href).on('enter', () => {
        if (!isDown) {
          handleActive(href)
        }
      })

      this.onclick = function(e) {
        var pos = $(href).offset().top - 10;
        $("html,body").animate({scrollTop: pos}, 300);
        setTimeout(() => {
          handleActive(href)
        }, 350)
        return false
      }
  })

  function handleActive(href) {
    document.querySelectorAll('.toc-link').forEach(elm => {
      elm.classList.remove('active')
    })
    document.querySelector(".toc [href='"+ href +"']").classList.add('active')
  }
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.1.20/jquery.fancybox.min.js"></script>


</body>
</html>
