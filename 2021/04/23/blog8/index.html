<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="本文主要对Linux下Redis数据库启动服务，提供的网络事件监听器的过程进行了源码分析追踪"><meta name="keywords" content="Linux,C/C++,Redis"><meta name="author" content="Xiaoru Zhu"><meta name="copyright" content="Xiaoru Zhu"><title>Redis源码笔记(1)之网络事件模型 | Kevin's Website</title><link rel="shortcut icon" href="/images/probe.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#i-Epoll-多路复用器"><span class="toc-number">1.</span> <span class="toc-text">[i] Epoll 多路复用器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ii-Epoll-Reactor监听模型"><span class="toc-number">2.</span> <span class="toc-text">[ii] Epoll Reactor监听模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#iii-Redis网络循环事件结构体"><span class="toc-number">3.</span> <span class="toc-text">[iii] Redis网络循环事件结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#全局结构体-server"><span class="toc-number">3.1.</span> <span class="toc-text">全局结构体 server</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#全局事件状态结构体-server-el"><span class="toc-number">3.2.</span> <span class="toc-text">全局事件状态结构体 server.el</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#iv-Redis事件监听服务源码追踪"><span class="toc-number">4.</span> <span class="toc-text">[iv] Redis事件监听服务源码追踪</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-的事件驱动总结如下"><span class="toc-number">4.1.</span> <span class="toc-text">Redis 的事件驱动总结如下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis主函数开始剖析"><span class="toc-number">4.2.</span> <span class="toc-text">Redis主函数开始剖析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#initServer函数跟踪"><span class="toc-number">4.3.</span> <span class="toc-text">initServer函数跟踪</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aeMain函数跟踪"><span class="toc-number">4.4.</span> <span class="toc-text">aeMain函数跟踪</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/self.jpg"></div><div class="author-info__name text-center">Xiaoru Zhu</div><div class="author-info__description text-center">Current Computer Science student at University of California, Irvine</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">4</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">1</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/sunset.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Kevin's Website</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/movies">Movies</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">Redis源码笔记(1)之网络事件模型</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-04-23</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Computer-Science/">Computer Science</a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">7.2k</span><span class="post-meta__separator">|</span><span>Reading time: 33 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><script src="/assets/js/APlayer.min.js"> </script><h1 id="i-Epoll-多路复用器"><a href="#i-Epoll-多路复用器" class="headerlink" title="[i] Epoll 多路复用器"></a>[i] Epoll 多路复用器</h1><p>Redis采用Epoll对网络I/O事件进行监听，例如与新client建立连接，读取客户端操作db请求等。相对select, poll方式它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，其内核态主要底层结构为一个<strong>Red-black Tree</strong>和<strong>Ready List</strong> (linked list)。</p>
<p>Red-black tree负责管理已注册的I/O事件（<strong>add, mod, delete等，操作性能为logn级</strong>），add (<strong>epoll_ctl(EPOLL_CTL_ADD)</strong>)时和相应fd绑定事件并注册回调函数ep_poll_callback，一旦监听文件的事件就绪，ep_poll_callback立即被调用，将fd对应的event(epi结构体.event)加入到Ready List中，当用户调用epoll_wait时，epoll加锁，将Ready List就绪的数据拷贝至用户空间，即epoll_event数组中。</p>
<blockquote>
<p><strong>底层原理详见:</strong>  <a href="https://segmentfault.com/a/1190000023730813" target="_blank" rel="noopener">epoll源码分析</a></p>
</blockquote>
<img src="/2021/04/23/blog8/epoll_demux.png" title="[epoll_demux]">  
<p>epoll除了提供select/pollIO事件的水平触发LT（Level Triggered）外，还提供了边沿触发ET（Edge Triggered），配合非阻塞fd，这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。</p>
<img src="/2021/04/23/blog8/epoll_ET_LT.png" title="[epoll_ET_LT]">
<h1 id="ii-Epoll-Reactor监听模型"><a href="#ii-Epoll-Reactor监听模型" class="headerlink" title="[ii] Epoll Reactor监听模型"></a>[ii] Epoll Reactor监听模型</h1><p>弃用data.fd，利用epoll_events的data.ptr泛型指针指向并关联自定义事件myEvent，同时向myEvent.call_back注册回调函数来处理未来的就绪事件，例如accpetconn(新增cfd连接)，recvdata(读取client连接传入数据)或senddata(向client写回数据)，因此无需对fd的类型进行判别，epoll_wait之后拿到ready list直接调用event.data.ptr指向的myEvent.call_back()函数处理相关事件</p>
<img src="/2021/04/23/blog8/epoll_reactor.png" title="[epoll_reactor]">
<h1 id="iii-Redis网络循环事件结构体"><a href="#iii-Redis网络循环事件结构体" class="headerlink" title="[iii] Redis网络循环事件结构体"></a>[iii] Redis网络循环事件结构体</h1><p>总的来说Linux Redis采用了<strong>Epoll Reactor</strong>模型，并配合<strong>非阻塞fd+ET模式</strong>对网络I/O事件进行监听，高并发处理效果非常好。下面来总结redis网络事件模型中的相关结构体：</p>
<h2 id="全局结构体-server"><a href="#全局结构体-server" class="headerlink" title="全局结构体 server"></a>全局结构体 <strong>server</strong></h2>   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量，记录几乎所有redis相关信息的描述符</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> <span class="title">server</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件状态 (重要)</span></span><br><span class="line">    aeEventLoop *el;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// PID 文件</span></span><br><span class="line">    <span class="keyword">char</span> *pidfile;              <span class="comment">/* PID file path */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Networking */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TCP 监听端口</span></span><br><span class="line">    <span class="keyword">int</span> port;                   <span class="comment">/* TCP listening port */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tcp_backlog;            <span class="comment">/* TCP listen() backlog */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 地址</span></span><br><span class="line">    <span class="keyword">char</span> *bindaddr[REDIS_BINDADDR_MAX]; <span class="comment">/* Addresses we should bind to */</span></span><br><span class="line">    <span class="comment">// 地址数量</span></span><br><span class="line">    <span class="keyword">int</span> bindaddr_count;         <span class="comment">/* Number of addresses in server.bindaddr[] */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// UNIX 套接字</span></span><br><span class="line">    <span class="keyword">char</span> *unixsocket;           <span class="comment">/* UNIX socket path */</span></span><br><span class="line">    <span class="keyword">mode_t</span> unixsocketperm;      <span class="comment">/* UNIX socket permission */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 描述符 listen_fd 数组</span></span><br><span class="line">    <span class="keyword">int</span> ipfd[REDIS_BINDADDR_MAX]; <span class="comment">/* TCP socket file descriptors */</span></span><br><span class="line">    <span class="comment">// 描述符数量</span></span><br><span class="line">    <span class="keyword">int</span> ipfd_count;             <span class="comment">/* Used slots in ipfd[] */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// UNIX 套接字文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> sofd;                   <span class="comment">/* Unix socket file descriptor */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cfd[REDIS_BINDADDR_MAX];<span class="comment">/* Cluster bus listening socket */</span></span><br><span class="line">    <span class="keyword">int</span> cfd_count;              <span class="comment">/* Used slots in cfd[] */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个链表，保存了所有客户端状态结构</span></span><br><span class="line">    <span class="built_in">list</span> *clients;              <span class="comment">/* List of active clients */</span></span><br><span class="line">    <span class="comment">// 链表，保存了所有待关闭的客户端</span></span><br><span class="line">    <span class="built_in">list</span> *clients_to_close;     <span class="comment">/* Clients to close asynchronously */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表，保存了所有从服务器，以及所有监视器</span></span><br><span class="line">    <span class="built_in">list</span> *slaves, *monitors;    <span class="comment">/* List of slaves and MONITORs */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器的当前客户端，仅用于崩溃报告</span></span><br><span class="line">    redisClient *current_client; <span class="comment">/* Current client, only used on crash report */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> clients_paused;         <span class="comment">/* True if clients are currently paused */</span></span><br><span class="line">    <span class="keyword">mstime_t</span> clients_pause_end_time; <span class="comment">/* Time when we undo clients_paused */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 网络错误</span></span><br><span class="line">    <span class="keyword">char</span> neterr[ANET_ERR_LEN];   <span class="comment">/* Error buffer for anet.c */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MIGRATE 缓存</span></span><br><span class="line">    dict *migrate_cached_sockets;<span class="comment">/* MIGRATE cached sockets */</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="全局事件状态结构体-server-el"><a href="#全局事件状态结构体-server-el" class="headerlink" title="全局事件状态结构体 server.el"></a>全局事件状态结构体 <strong>server.el</strong></h2><blockquote><p>即redis的事件驱动循环中心(<strong>aeEventLoop</strong>)，内部有3个主要的数据结构：<strong>文件事件结构体</strong>，<strong>时间事件结构体</strong>和<strong>触发事件结构体</strong>。</p>
</blockquote>
<ul>
<li><p>server.el 结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">aeEventLoop *el;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* State of an event based program </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 事件处理器的状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeEventLoop</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前已注册的最大描述符</span></span><br><span class="line">    <span class="keyword">int</span> maxfd;   <span class="comment">/* highest file descriptor currently registered so far */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前已追踪的最大描述符</span></span><br><span class="line">    <span class="keyword">int</span> setsize; <span class="comment">/* max number of file descriptors tracked */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于生成时间事件 id</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeEventNextId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一次执行时间事件的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> lastTime;     <span class="comment">/* Used to detect system clock skew */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已注册的文件事件</span></span><br><span class="line">    aeFileEvent *events; <span class="comment">/* Registered events */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已就绪的文件事件</span></span><br><span class="line">    aeFiredEvent *fired; <span class="comment">/* Fired events */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间事件</span></span><br><span class="line">    aeTimeEvent *timeEventHead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件处理器的开关</span></span><br><span class="line">    <span class="keyword">int</span> stop;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 多路复用库的私有数据 epoll相关</span></span><br><span class="line">    <span class="keyword">void</span> *apidata; <span class="comment">/* This is used for polling API specific data */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在处理事件前要执行的函数</span></span><br><span class="line">    aeBeforeSleepProc *beforesleep;</span><br><span class="line"></span><br><span class="line">&#125; aeEventLoop;	</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>aeEventLopp.apidata结构，存储epoll相关数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">apidata = struct aeApiState* state;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 事件状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeApiState</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// epoll_event 实例描述符</span></span><br><span class="line">    <span class="keyword">int</span> epfd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件槽</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; aeApiState;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>文件事件结构体 (<strong>aeFileEvent</strong>): 维护I/O事件表，相当于libevent中自定义myevent结构，内部包含mask(对应epoll中的events标识位) + w/rfileProc回调处理函数（call_back函数指针）</li>
<li>时间事件结构体 (<strong>aeTimeEvent</strong>): 时间事件…</li>
<li><p>触发事件结构体 (<strong>aeFiredEvent</strong>): 已就绪的事件，每次轮询epoll_wait后会将apidata中的就绪event信息拷贝至aeFiredEvent数组，包含已就绪的fd和mask</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* File event structure</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 文件事件结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFileEvent</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听事件类型掩码，</span></span><br><span class="line">    <span class="comment">// 值可以是 AE_READABLE 或 AE_WRITABLE ，</span></span><br><span class="line">    <span class="comment">// 或者 AE_READABLE | AE_WRITABLE</span></span><br><span class="line">    <span class="keyword">int</span> mask; <span class="comment">/* one of AE_(READABLE|WRITABLE) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读事件处理器</span></span><br><span class="line">    aeFileProc *rfileProc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写事件处理器</span></span><br><span class="line">    aeFileProc *wfileProc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多路复用库的私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *clientData;</span><br><span class="line"></span><br><span class="line">&#125; aeFileEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Time event structure</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 时间事件结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间事件的唯一标识符</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id; <span class="comment">/* time event identifier. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件的到达时间</span></span><br><span class="line">    <span class="keyword">long</span> when_sec; <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="keyword">long</span> when_ms; <span class="comment">/* milliseconds */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件处理函数</span></span><br><span class="line">    aeTimeProc *timeProc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件释放函数</span></span><br><span class="line">    aeEventFinalizerProc *finalizerProc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多路复用库的私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *clientData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个时间事件结构，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; aeTimeEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A fired event</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 已就绪事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFiredEvent</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已就绪文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件类型掩码，</span></span><br><span class="line">    <span class="comment">// 值可以是 AE_READABLE 或 AE_WRITABLE</span></span><br><span class="line">    <span class="comment">// 或者是两者的或</span></span><br><span class="line">    <span class="keyword">int</span> mask;</span><br><span class="line"></span><br><span class="line">&#125; aeFiredEvent;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="iv-Redis事件监听服务源码追踪"><a href="#iv-Redis事件监听服务源码追踪" class="headerlink" title="[iv] Redis事件监听服务源码追踪"></a>[iv] Redis事件监听服务源码追踪</h1><h2 id="Redis-的事件驱动总结如下"><a href="#Redis-的事件驱动总结如下" class="headerlink" title="Redis 的事件驱动总结如下"></a>Redis 的事件驱动总结如下</h2><ul>
<li><p>初始化事件循环结构体 (aeEventLoop)</p>
</li>
<li><p>注册监听套接字的读事件 (aeFileEvent)</p>
</li>
<li><p>注册定时事件 (aeTimeEvent)</p>
</li>
<li><p>进入事件循环 (aeMain(server.el);)</p>
</li>
<li><p>如果监听套接字变为可读，会接收客户端请求，并为对应的套接字注册读事件</p>
</li>
<li><p>如果与客户端连接的套接字变为可读，执行相应的操作</p>
</li>
</ul>
<img src="/2021/04/23/blog8/event_model.png" title="[event_model]">  
<h2 id="Redis主函数开始剖析"><a href="#Redis主函数开始剖析" class="headerlink" title="Redis主函数开始剖析"></a>Redis主函数开始剖析</h2><ul>
<li><p>主函数main位于<strong>redis.c</strong>文件的底部位置，网络服务主要处理函数如下:</p>
<ul>
<li><strong>initServerConfig</strong>: 初始化服务器配置，例如上设置默认监听端口号6379、aof配置信息、集群配置等</li>
<li><strong>initServer</strong>: 创建并初始化服务器数据结构，例如初始化全局事件循环结构体server.el (aeEventLoop)、创建监听fd (执行socket -&gt; bind -&gt; listen函数，得到listen_fd数组，存往server.ipfd指针)、初始化aeTimeEvent并注册时间事件、初始化aeFileEvent并注册监听套接字的读事件</li>
<li><p><strong>aeMain</strong>: 开始通过多路复用器循环监听I/O事件，并处理各项读写/时间事件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">  	<span class="comment">// 初始化服务器配置</span></span><br><span class="line">    initServerConfig();</span><br><span class="line">    <span class="comment">// 创建并初始化服务器数据结构</span></span><br><span class="line">    initServer();</span><br><span class="line">    <span class="comment">// 运行事件处理器，一直到服务器关闭为止</span></span><br><span class="line">    aeSetBeforeSleepProc(server.el,beforeSleep);</span><br><span class="line">    aeMain(server.el); <span class="comment">// 循环监听事件 while(!stop)</span></span><br><span class="line">    <span class="comment">// 服务器关闭，停止事件循环</span></span><br><span class="line">    aeDeleteEventLoop(server.el);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="initServer函数跟踪"><a href="#initServer函数跟踪" class="headerlink" title="initServer函数跟踪"></a><strong>initServer</strong>函数跟踪</h2><blockquote><p>这里省略 <strong>initServerConfig</strong> - 其内容主要为对全局server结构体的初始化</p>
</blockquote>
   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="comment">// 初始化全局EventLoop结构体</span></span><br><span class="line">    server.el = aeCreateEventLoop(server.maxclients+REDIS_EVENTLOOP_FDSET_INCR);</span><br><span class="line">    server.db = zmalloc(<span class="keyword">sizeof</span>(redisDb)*server.dbnum);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Open the TCP listening socket for the user commands. */</span></span><br><span class="line">    <span class="comment">// 打开 TCP 监听端口，用于等待客户端的命令请求</span></span><br><span class="line">    <span class="comment">// 创建监听listen_fd (socket -&gt; bind -&gt; listen -&gt; Get ipfd)</span></span><br><span class="line">    <span class="keyword">if</span> (server.port != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == REDIS_ERR)</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* Abort if there are no listening sockets at all. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.ipfd_count == <span class="number">0</span> &amp;&amp; server.sofd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        redisLog(REDIS_WARNING, <span class="string">"Configured to not listen anywhere, exiting."</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Create the serverCron() time event, that's our main way to process</span></span><br><span class="line"><span class="comment">     * background operations. */</span></span><br><span class="line">    <span class="comment">// 为 serverCron() 创建时间事件</span></span><br><span class="line">    <span class="keyword">if</span>(aeCreateTimeEvent(server.el, <span class="number">1</span>, serverCron, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == AE_ERR) &#123;</span><br><span class="line">        redisPanic(<span class="string">"Can't create the serverCron time event."</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Create an event handler for accepting new connections in TCP and Unix</span></span><br><span class="line"><span class="comment">     * domain sockets. */</span></span><br><span class="line">    <span class="comment">// 为 TCP 连接关联连接应答（accept）处理器</span></span><br><span class="line">    <span class="comment">// 用于接受并应答客户端的 connect() 调用</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">		<span class="comment">// 相当于livevent中的reactor模型中对listenfd进行set_event+add_event操作</span></span><br><span class="line">		<span class="comment">// aeCreateFileEvent函数:</span></span><br><span class="line">		<span class="comment">//     server.el.events -&gt; global_events数组</span></span><br><span class="line">		<span class="comment">//     server.ipfd[j] -&gt; listen_fd</span></span><br><span class="line">		<span class="comment">//     AE_READABLE -&gt; EPOLLIN</span></span><br><span class="line">		<span class="comment">//     acceptTcpHandler -&gt; acceptconn</span></span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,</span><br><span class="line">            acceptTcpHandler,<span class="literal">NULL</span>) == AE_ERR)</span><br><span class="line">            &#123;</span><br><span class="line">                redisPanic(</span><br><span class="line">                    <span class="string">"Unrecoverable error creating server.ipfd file event."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>aeCreateEventLoop</strong>函数: 初始化I/O事件表和各类事件结构，其中<strong>eventLoop-&gt;events</strong>为aeFileEvent类型的数组，他的idx表示fd，element是aeFileEvent结构体。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">server.el = aeCreateEventLoop(server.maxclients+REDIS_EVENTLOOP_FDSET_INCR);</span><br><span class="line"></span><br><span class="line"><span class="function">aeEventLoop *<span class="title">aeCreateEventLoop</span><span class="params">(<span class="keyword">int</span> setsize)</span> </span>&#123;</span><br><span class="line">    aeEventLoop *eventLoop;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建事件状态结构</span></span><br><span class="line">    <span class="keyword">if</span> ((eventLoop = zmalloc(<span class="keyword">sizeof</span>(*eventLoop))) == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化文件事件结构和已就绪文件事件结构数组</span></span><br><span class="line">    eventLoop-&gt;events = zmalloc(<span class="keyword">sizeof</span>(aeFileEvent)*setsize);</span><br><span class="line">    eventLoop-&gt;fired = zmalloc(<span class="keyword">sizeof</span>(aeFiredEvent)*setsize);</span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;events == <span class="literal">NULL</span> || eventLoop-&gt;fired == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="comment">// 设置数组大小</span></span><br><span class="line">    eventLoop-&gt;setsize = setsize;</span><br><span class="line">    <span class="comment">// 初始化执行最近一次执行时间</span></span><br><span class="line">    eventLoop-&gt;lastTime = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化时间事件结构</span></span><br><span class="line">    eventLoop-&gt;timeEventHead = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;timeEventNextId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;maxfd = <span class="number">-1</span>;</span><br><span class="line">    eventLoop-&gt;beforesleep = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// 创建epoll实例，调用epoll_create，初始化等待队列epoll_event</span></span><br><span class="line">    <span class="keyword">if</span> (aeApiCreate(eventLoop) == <span class="number">-1</span>) <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Events with mask == AE_NONE are not set. So let's initialize the</span></span><br><span class="line"><span class="comment">     * vector with it. */</span></span><br><span class="line">    <span class="comment">// 初始化监听事件</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; setsize; i++)</span><br><span class="line">        eventLoop-&gt;events[i].mask = AE_NONE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回事件循环</span></span><br><span class="line">    <span class="keyword">return</span> eventLoop;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">if</span> (eventLoop) &#123;</span><br><span class="line">        zfree(eventLoop-&gt;events);</span><br><span class="line">        zfree(eventLoop-&gt;fired);</span><br><span class="line">        zfree(eventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的 epoll 实例，并将它赋值给 eventLoop</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    aeApiState *state = zmalloc(<span class="keyword">sizeof</span>(aeApiState));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!state) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化事件槽空间 - epoll_event就绪队列初始化</span></span><br><span class="line">    state-&gt;events = zmalloc(<span class="keyword">sizeof</span>(struct epoll_event)*eventLoop-&gt;setsize);</span><br><span class="line">    <span class="keyword">if</span> (!state-&gt;events) &#123;</span><br><span class="line">        zfree(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键代码，创建 epoll 实例</span></span><br><span class="line">    state-&gt;epfd = epoll_create(<span class="number">1024</span>); <span class="comment">/* 1024 is just a hint for the kernel */</span></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;epfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        zfree(state-&gt;events);</span><br><span class="line">        zfree(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值给 eventLoop</span></span><br><span class="line">    eventLoop-&gt;apidata = state;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>listenToPort</strong>函数:</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listenToPort</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">int</span> *fds, <span class="keyword">int</span> *count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// fds为监听server.ipfd数组</span></span><br><span class="line">    <span class="comment">/* Force binding of 0.0.0.0 if no bind address is specified, always</span></span><br><span class="line"><span class="comment">     * entering the loop if j == 0. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.bindaddr_count == <span class="number">0</span>) server.bindaddr[<span class="number">0</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.bindaddr_count || j == <span class="number">0</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.bindaddr[j] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// ...ipv6省略</span></span><br><span class="line">			<span class="comment">// 初始化监听服务 (socket -&gt; bind -&gt; listen -&gt; return listen_fd)</span></span><br><span class="line">			<span class="comment">// fds --&gt;&gt; server.ipfd</span></span><br><span class="line">            fds[*count] = anetTcpServer(server.neterr,port,<span class="literal">NULL</span>,</span><br><span class="line">                server.tcp_backlog);</span><br><span class="line">            <span class="keyword">if</span> (fds[*count] != ANET_ERR) &#123;</span><br><span class="line">                anetNonBlock(<span class="literal">NULL</span>,fds[*count]);</span><br><span class="line">                (*count)++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Exit the loop if we were able to bind * on IPv4 or IPv6,</span></span><br><span class="line"><span class="comment">             * otherwise fds[*count] will be ANET_ERR and we'll print an</span></span><br><span class="line"><span class="comment">             * error and return to the caller with an error. */</span></span><br><span class="line">            <span class="keyword">if</span> (*count) <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strchr</span>(server.bindaddr[j],<span class="string">':'</span>)) &#123;</span><br><span class="line">            <span class="comment">/* Bind IPv6 address. */</span></span><br><span class="line">            fds[*count] = anetTcp6Server(server.neterr,port,server.bindaddr[j],</span><br><span class="line">                server.tcp_backlog);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Bind IPv4 address. */</span></span><br><span class="line">            fds[*count] = anetTcpServer(server.neterr,port,server.bindaddr[j],</span><br><span class="line">                server.tcp_backlog);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fds[*count] == ANET_ERR) &#123;</span><br><span class="line">            redisLog(REDIS_WARNING,</span><br><span class="line">                <span class="string">"Creating Server TCP listening socket %s:%d: %s"</span>,</span><br><span class="line">                server.bindaddr[j] ? server.bindaddr[j] : <span class="string">"*"</span>,</span><br><span class="line">                port, server.neterr);</span><br><span class="line">            <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        anetNonBlock(<span class="literal">NULL</span>,fds[*count]);</span><br><span class="line">        (*count)++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>anetTcpServer</strong>函数，创建监听socket返回fd (socket -&gt; bind -&gt; listen(fd)):</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpServer</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> port, <span class="keyword">char</span> *bindaddr, <span class="keyword">int</span> backlog)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _anetTcpServer(err, port, bindaddr, AF_INET, backlog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _anetTcpServer(<span class="keyword">char</span> *err, <span class="keyword">int</span> port, <span class="keyword">char</span> *bindaddr, <span class="keyword">int</span> af, <span class="keyword">int</span> backlog) &#123;</span><br><span class="line">    <span class="keyword">int</span> s, rv; <span class="comment">/* s为listen fd 返回 */</span></span><br><span class="line">    <span class="keyword">char</span> _port[<span class="number">6</span>];  <span class="comment">/* strlen("65535") */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">servinfo</span>, *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(_port,<span class="number">6</span>,<span class="string">"%d"</span>,port);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints,<span class="number">0</span>,<span class="keyword">sizeof</span>(hints));</span><br><span class="line">    hints.ai_family = af;</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">    hints.ai_flags = AI_PASSIVE;    <span class="comment">/* No effect if bindaddr != NULL */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((rv = getaddrinfo(bindaddr,_port,&amp;hints,&amp;servinfo)) != <span class="number">0</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">"%s"</span>, gai_strerror(rv));</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (p = servinfo; p != <span class="literal">NULL</span>; p = p-&gt;ai_next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s = socket(p-&gt;ai_family,p-&gt;ai_socktype,p-&gt;ai_protocol)) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (af == AF_INET6 &amp;&amp; anetV6Only(err,s) == ANET_ERR) <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="keyword">if</span> (anetSetReuseAddr(err,s) == ANET_ERR) <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="keyword">if</span> (anetListen(err,s,p-&gt;ai_addr,p-&gt;ai_addrlen,backlog) == ANET_ERR) <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">"unable to bind socket"</span>);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    s = ANET_ERR;</span><br><span class="line">end:</span><br><span class="line">    freeaddrinfo(servinfo);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">anetListen</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> s, struct sockaddr *sa, <span class="keyword">socklen_t</span> len, <span class="keyword">int</span> backlog)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bind(s,sa,len) == <span class="number">-1</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">"bind: %s"</span>, strerror(errno));</span><br><span class="line">        close(s);</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listen(s, backlog) == <span class="number">-1</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">"listen: %s"</span>, strerror(errno));</span><br><span class="line">        close(s);</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ANET_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>aeCreateFileEvent</strong>函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE, acceptTcpHandler,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeCreateFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask,</span></span></span><br><span class="line"><span class="function"><span class="params">        aeFileProc *proc, <span class="keyword">void</span> *clientData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= eventLoop-&gt;setsize) &#123;</span><br><span class="line">        errno = ERANGE;</span><br><span class="line">        <span class="keyword">return</span> AE_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= eventLoop-&gt;setsize) <span class="keyword">return</span> AE_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出文件事件结构</span></span><br><span class="line">    <span class="comment">// eventLoop-&gt;events：相当于epoll反应堆模型中的全局MyEvent数组</span></span><br><span class="line">    aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听指定 fd 的指定事件 linux对应epoll上树操作</span></span><br><span class="line">    <span class="keyword">if</span> (aeApiAddEvent(eventLoop, fd, mask) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> AE_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置文件事件类型，以及事件的处理器</span></span><br><span class="line">    fe-&gt;mask |= mask;</span><br><span class="line">	<span class="comment">// 注册回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) fe-&gt;rfileProc = proc;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) fe-&gt;wfileProc = proc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    fe-&gt;clientData = clientData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有需要，更新事件处理器的最大 fd</span></span><br><span class="line">    <span class="keyword">if</span> (fd &gt; eventLoop-&gt;maxfd)</span><br><span class="line">        eventLoop-&gt;maxfd = fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> AE_OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>aeApiAddEvent</strong>函数: 关联给定事件到fd，取出全局变量server的文件事件(aeFileEvent)server.el.events[listen_fd]，将事件回调函数、读写类型枚举mask写入</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ee</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the fd was already monitored for some event, we need a MOD</span></span><br><span class="line"><span class="comment">     * operation. Otherwise we need an ADD operation. </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> op = eventLoop-&gt;events[fd].mask == AE_NONE ?</span><br><span class="line">            EPOLL_CTL_ADD : EPOLL_CTL_MOD;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册事件到 epoll</span></span><br><span class="line">    ee.events = <span class="number">0</span>;</span><br><span class="line">    mask |= eventLoop-&gt;events[fd].mask; <span class="comment">/* Merge old events */</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) ee.events |= EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;</span><br><span class="line">    ee.data.u64 = <span class="number">0</span>; <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    ee.data.fd = fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>acceptTcpHandler</strong> [<strong>回调函数</strong>]: 在<strong>initServer</strong>的<strong>aeCreateFileEvent</strong>函数调用中被注册到listen_fd对应的文件事件(server.el.events[listen_fd])。||  当后面listen_fd就绪时，开始调用<strong>anetTcpAccept</strong>函数与客户端建立TCP连接，再通过调用<strong>acceptCommonHandler</strong>函数创建客户端结构体、初始化状态，最后调用<strong>aeCreateFileEvent</strong>将client_fd(cfd)及对应的事件注册到全局I/O事件表server.el.events[]中，该cfd的回调函数是<strong>readQueryFromClient</strong>。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acceptTcpHandler</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cport, cfd, max = MAX_ACCEPTS_PER_CALL;</span><br><span class="line">    <span class="keyword">char</span> cip[REDIS_IP_STR_LEN];</span><br><span class="line">    REDIS_NOTUSED(el);</span><br><span class="line">    REDIS_NOTUSED(mask);</span><br><span class="line">    REDIS_NOTUSED(privdata);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(max--) &#123;</span><br><span class="line">        <span class="comment">// accept 客户端连接</span></span><br><span class="line">        cfd = anetTcpAccept(server.neterr, fd, cip, <span class="keyword">sizeof</span>(cip), &amp;cport);</span><br><span class="line">        <span class="keyword">if</span> (cfd == ANET_ERR) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">                redisLog(REDIS_WARNING,</span><br><span class="line">                    <span class="string">"Accepting client connection: %s"</span>, server.neterr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        redisLog(REDIS_VERBOSE,<span class="string">"Accepted %s:%d"</span>, cip, cport);</span><br><span class="line">        <span class="comment">// 为客户端创建客户端状态（redisClient）</span></span><br><span class="line">        acceptCommonHandler(cfd,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>anetTcpAccept</strong>函数: 调用<strong>anetGenericAccept</strong>函数建立TCP连接</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * TCP 连接 accept 函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpAccept</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> s, <span class="keyword">char</span> *ip, <span class="keyword">size_t</span> ip_len, <span class="keyword">int</span> *port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> salen = <span class="keyword">sizeof</span>(sa);</span><br><span class="line">    <span class="comment">// 建立tcp连接</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = anetGenericAccept(err,s,(struct sockaddr*)&amp;sa,&amp;salen)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sa.ss_family == AF_INET) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">s</span> = (<span class="title">struct</span> <span class="title">sockaddr_in</span> *)&amp;<span class="title">sa</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (ip) inet_ntop(AF_INET,(<span class="keyword">void</span>*)&amp;(s-&gt;sin_addr),ip,ip_len);</span><br><span class="line">        <span class="comment">// 字节序转换 big-endian to little-endian</span></span><br><span class="line">        <span class="keyword">if</span> (port) *port = ntohs(s-&gt;sin_port);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        struct sockaddr_in6 *s = (struct sockaddr_in6 *)&amp;sa;</span><br><span class="line">        <span class="keyword">if</span> (ip) inet_ntop(AF_INET6,(<span class="keyword">void</span>*)&amp;(s-&gt;sin6_addr),ip,ip_len);</span><br><span class="line">        <span class="keyword">if</span> (port) *port = ntohs(s-&gt;sin6_port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">anetGenericAccept</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> s, struct sockaddr *sa, <span class="keyword">socklen_t</span> *len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        fd = accept(s,sa,len);</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                anetSetError(err, <span class="string">"accept: %s"</span>, strerror(errno));</span><br><span class="line">                <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>acceptCommonHandler</strong>函数: 调用<strong>createClient</strong>函数初始化新client结构，并且<strong>createClient</strong>会给新的client_fd向全局I/O事件表server.el.events[]中注册读事件监听，即为cfd调用<strong>aeCreateFileEvent</strong>函数，call_back为<strong>readQueryFromClient</strong>函数:</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">acceptCommonHandler</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建客户端</span></span><br><span class="line">    redisClient *c;</span><br><span class="line">    <span class="keyword">if</span> ((c = createClient(fd)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        redisLog(REDIS_WARNING,</span><br><span class="line">            <span class="string">"Error registering fd event for the new client: %s (fd=%d)"</span>,</span><br><span class="line">            strerror(errno),fd);</span><br><span class="line">        close(fd); <span class="comment">/* May be already closed, just ignore errors */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新连接次数</span></span><br><span class="line">    server.stat_numconnections++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 FLAG</span></span><br><span class="line">    c-&gt;flags |= flags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个新客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">redisClient *<span class="title">createClient</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    redisClient *c = zmalloc(<span class="keyword">sizeof</span>(redisClient));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* passing -1 as fd it is possible to create a non connected client.</span></span><br><span class="line"><span class="comment">     * This is useful since all the Redis commands needs to be executed</span></span><br><span class="line"><span class="comment">     * in the context of a client. When commands are executed in other</span></span><br><span class="line"><span class="comment">     * contexts (for instance a Lua script) we need a non connected client. */</span></span><br><span class="line">    <span class="comment">// 当 fd 不为 -1 时，创建带网络连接的客户端</span></span><br><span class="line">    <span class="comment">// 如果 fd 为 -1 ，那么创建无网络连接的伪客户端</span></span><br><span class="line">    <span class="comment">// 因为 Redis 的命令必须在客户端的上下文中使用，所以在执行 Lua 环境中的命令时</span></span><br><span class="line">    <span class="comment">// 需要用到这种伪终端</span></span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 非阻塞: 内部使用fcntl(fd, NONBLOCK)</span></span><br><span class="line">        anetNonBlock(<span class="literal">NULL</span>,fd);</span><br><span class="line">        <span class="comment">// 禁用 Nagle 算法</span></span><br><span class="line">        anetEnableTcpNoDelay(<span class="literal">NULL</span>,fd);</span><br><span class="line">        <span class="comment">// 设置 keep alive</span></span><br><span class="line">        <span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">            anetKeepAlive(<span class="literal">NULL</span>,fd,server.tcpkeepalive);</span><br><span class="line">        <span class="comment">// 绑定读事件到事件 loop （开始接收命令请求）</span></span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el,fd,AE_READABLE,</span><br><span class="line">            readQueryFromClient, c) == AE_ERR) &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">            zfree(c);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化各个属性</span></span><br><span class="line">    <span class="comment">// 默认数据库</span></span><br><span class="line">    selectDb(c,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 套接字</span></span><br><span class="line">    c-&gt;fd = fd;</span><br><span class="line">    <span class="comment">// 名字</span></span><br><span class="line">    c-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回客户端</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>readQueryFromClient</strong>[<strong>回调函数</strong>]: 当和client_fd就绪时调用，即从client读取请求内容，并在最后调用<strong>processInputBuffer</strong>函数进行解析、执行命令:</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 读取客户端的查询缓冲区内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readQueryFromClient</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    redisClient *c = (redisClient*) privdata;</span><br><span class="line">    <span class="keyword">int</span> nread, readlen;</span><br><span class="line">    <span class="keyword">size_t</span> qblen;</span><br><span class="line">    REDIS_NOTUSED(el);</span><br><span class="line">    REDIS_NOTUSED(mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器的当前客户端</span></span><br><span class="line">    server.current_client = c;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读入长度（默认为 16 MB）</span></span><br><span class="line">    readlen = REDIS_IOBUF_LEN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this is a multi bulk request, and we are processing a bulk reply</span></span><br><span class="line"><span class="comment">     * that is large enough, try to maximize the probability that the query</span></span><br><span class="line"><span class="comment">     * buffer contains exactly the SDS string representing the object, even</span></span><br><span class="line"><span class="comment">     * at the risk of requiring more read(2) calls. This way the function</span></span><br><span class="line"><span class="comment">     * processMultiBulkBuffer() can avoid copying buffers to create the</span></span><br><span class="line"><span class="comment">     * Redis Object representing the argument. */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;reqtype == REDIS_REQ_MULTIBULK &amp;&amp; c-&gt;multibulklen &amp;&amp; c-&gt;bulklen != <span class="number">-1</span></span><br><span class="line">        &amp;&amp; c-&gt;bulklen &gt;= REDIS_MBULK_BIG_ARG)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> remaining = (<span class="keyword">unsigned</span>)(c-&gt;bulklen+<span class="number">2</span>)-sdslen(c-&gt;querybuf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; readlen) readlen = remaining;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取查询缓冲区当前内容的长度</span></span><br><span class="line">    <span class="comment">// 如果读取出现 short read ，那么可能会有内容滞留在读取缓冲区里面</span></span><br><span class="line">    <span class="comment">// 这些滞留内容也许不能完整构成一个符合协议的命令，</span></span><br><span class="line">    qblen = sdslen(c-&gt;querybuf);</span><br><span class="line">    <span class="comment">// 如果有需要，更新缓冲区内容长度的峰值（peak）</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;querybuf_peak &lt; qblen) c-&gt;querybuf_peak = qblen;</span><br><span class="line">    <span class="comment">// 为查询缓冲区分配空间</span></span><br><span class="line">    c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen);</span><br><span class="line">    <span class="comment">// 读入内容到查询缓存</span></span><br><span class="line">    nread = read(fd, c-&gt;querybuf+qblen, readlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入出错</span></span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">            nread = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redisLog(REDIS_VERBOSE, <span class="string">"Reading from client: %s"</span>,strerror(errno));</span><br><span class="line">            freeClient(c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 遇到 EOF</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">        redisLog(REDIS_VERBOSE, <span class="string">"Client closed connection"</span>);</span><br><span class="line">        freeClient(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nread) &#123;</span><br><span class="line">        <span class="comment">// 根据内容，更新查询缓冲区（SDS） free 和 len 属性</span></span><br><span class="line">        <span class="comment">// 并将 '\0' 正确地放到内容的最后</span></span><br><span class="line">        sdsIncrLen(c-&gt;querybuf,nread);</span><br><span class="line">        <span class="comment">// 记录服务器和客户端最后一次互动的时间</span></span><br><span class="line">        c-&gt;lastinteraction = server.unixtime;</span><br><span class="line">        <span class="comment">// 如果客户端是 master 的话，更新它的复制偏移量</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_MASTER) c-&gt;reploff += nread;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在 nread == -1 且 errno == EAGAIN 时运行</span></span><br><span class="line">        server.current_client = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询缓冲区长度超出服务器最大缓冲区长度</span></span><br><span class="line">    <span class="comment">// 清空缓冲区并释放客户端</span></span><br><span class="line">    <span class="keyword">if</span> (sdslen(c-&gt;querybuf) &gt; server.client_max_querybuf_len) &#123;</span><br><span class="line">        sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();</span><br><span class="line"></span><br><span class="line">        bytes = sdscatrepr(bytes,c-&gt;querybuf,<span class="number">64</span>);</span><br><span class="line">        redisLog(REDIS_WARNING,<span class="string">"Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)"</span>, ci, bytes);</span><br><span class="line">        sdsfree(ci);</span><br><span class="line">        sdsfree(bytes);</span><br><span class="line">        freeClient(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从查询缓存重读取内容，创建参数，并执行命令</span></span><br><span class="line">    <span class="comment">// 函数会执行到缓存中的所有内容都被处理完为止</span></span><br><span class="line">    processInputBuffer(c);</span><br><span class="line"></span><br><span class="line">    server.current_client = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>processInputBuffer</strong>函数: 代码略，首先会进行多重判断，如果无误则在最后会调用<strong>processCommand(redisClient *c)</strong>函数处理命令;</p>
</li>
<li><p><strong>processCommand</strong>函数: 此时说明我们已经读入了一个完整的命令到客户端，本函数负责执行这个命令。首先会对命令进行解析判断合法性，通过则调用<strong>call(redisClient *c, int flags)</strong>函数执行命令，其中会执行<strong>c-&gt;cmd-&gt;proc(c)</strong>，该回调函数里会调用<strong>addReply(redisClient <em>c, robj </em>obj)</strong>函数向全局I/O事件表中注册写事件，返回客户端:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">/* Now lookup the command and check ASAP about trivial error conditions</span></span><br><span class="line"><span class="comment">     * such as wrong arity, bad command name and so forth. */</span></span><br><span class="line">    <span class="comment">// redis 首先根据客户端给出的命令字在命令表中查找对应的 c-&gt;cmd, 即 struct redisCommand().</span></span><br><span class="line">    c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有找到命令</span></span><br><span class="line">    <span class="keyword">if</span> (!c-&gt;cmd) &#123;</span><br><span class="line">        flagTransaction(c);</span><br><span class="line">        addReplyErrorFormat(c,<span class="string">"unknown command '%s'"</span>,</span><br><span class="line">            (<span class="keyword">char</span>*)c-&gt;argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">        <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">    <span class="comment">// 参数个数不符合</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((c-&gt;cmd-&gt;arity &gt; <span class="number">0</span> &amp;&amp; c-&gt;cmd-&gt;arity != c-&gt;argc) ||</span><br><span class="line">               (c-&gt;argc &lt; c-&gt;cmd-&gt;arity)) &#123;</span><br><span class="line">        flagTransaction(c);</span><br><span class="line">        addReplyErrorFormat(c,<span class="string">"wrong number of arguments for '%s' command"</span>,</span><br><span class="line">            c-&gt;cmd-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">    <span class="comment">// 加入命令队列的情况</span></span><br><span class="line">    <span class="comment">/* Exec the command */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_MULTI &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)&#123;</span><br><span class="line">        <span class="comment">// 命令入队</span></span><br><span class="line">        queueMultiCommand(c);</span><br><span class="line">        addReply(c,shared.queued);</span><br><span class="line">    <span class="comment">// 真正执行命令。</span></span><br><span class="line">    <span class="comment">// 注意，如果是设置了多命令模式，那么不是直接执行命令，而是让命令入队</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 关键代码 - 处理</span></span><br><span class="line">        call(c,REDIS_CALL_FULL);</span><br><span class="line">        <span class="keyword">if</span> (listLength(server.ready_keys))</span><br><span class="line">            handleClientsBlockedOnLists();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>call</strong>函数: 其处理的事很多，代码略。这里只关注调用了命令的回调函数 <strong>c-&gt;cmd-&gt;proc(c);</strong> <strong>proc</strong>是一个函数指针(类型: <strong>typedef void redisCommandProc(redisClient *c);</strong>)，之前在<strong>processCommand</strong>里就会先通过<strong>lookupCommand</strong>函数根据参数<strong>c</strong>解析的命令内容，指向具体的地址。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局结构redisCommandTable，存储redis所有命令</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> <span class="title">redisCommandTable</span>[] = &#123;</span></span><br><span class="line">    &#123;<span class="string">"get"</span>,getCommand,<span class="number">2</span>,<span class="string">"r"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"set"</span>,setCommand,<span class="number">-3</span>,<span class="string">"wm"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"setnx"</span>,setnxCommand,<span class="number">3</span>,<span class="string">"wm"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"setex"</span>,setexCommand,<span class="number">4</span>,<span class="string">"wm"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"psetex"</span>,psetexCommand,<span class="number">4</span>,<span class="string">"wm"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"append"</span>,appendCommand,<span class="number">3</span>,<span class="string">"wm"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"strlen"</span>,strlenCommand,<span class="number">2</span>,<span class="string">"r"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"del"</span>,delCommand,<span class="number">-2</span>,<span class="string">"w"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"exists"</span>,existsCommand,<span class="number">2</span>,<span class="string">"r"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"setbit"</span>,setbitCommand,<span class="number">4</span>,<span class="string">"wm"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"getbit"</span>,getbitCommand,<span class="number">3</span>,<span class="string">"r"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"setrange"</span>,setrangeCommand,<span class="number">4</span>,<span class="string">"wm"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"getrange"</span>,getrangeCommand,<span class="number">4</span>,<span class="string">"r"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"substr"</span>,getrangeCommand,<span class="number">4</span>,<span class="string">"r"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"incr"</span>,incrCommand,<span class="number">2</span>,<span class="string">"wm"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"decr"</span>,decrCommand,<span class="number">2</span>,<span class="string">"wm"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"mget"</span>,mgetCommand,<span class="number">-2</span>,<span class="string">"r"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> &#123;</span></span><br><span class="line">    <span class="comment">// 命令名字</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">// 实现函数</span></span><br><span class="line">    redisCommandProc *proc;</span><br><span class="line">    <span class="comment">// 参数个数</span></span><br><span class="line">    <span class="keyword">int</span> arity;</span><br><span class="line">    <span class="comment">// 字符串表示的 FLAG</span></span><br><span class="line">    <span class="keyword">char</span> *sflags; <span class="comment">/* Flags as string representation, one char per flag. */</span></span><br><span class="line">    <span class="comment">// 实际 FLAG</span></span><br><span class="line">    <span class="keyword">int</span> flags;    <span class="comment">/* The actual flags, obtained from the 'sflags' field. */</span></span><br><span class="line">    <span class="comment">/* Use a function to determine keys arguments in a command line.</span></span><br><span class="line"><span class="comment">     * Used for Redis Cluster redirect. */</span></span><br><span class="line">    <span class="comment">// 从命令中判断命令的键参数。在 Redis 集群转向时使用。</span></span><br><span class="line">    redisGetKeysProc *getkeys_proc;</span><br><span class="line">    <span class="comment">/* What keys should be loaded in background when calling this command? */</span></span><br><span class="line">    <span class="comment">// 指定哪些参数是 key</span></span><br><span class="line">    <span class="keyword">int</span> firstkey; <span class="comment">/* The first argument that's a key (0 = no keys) */</span></span><br><span class="line">    <span class="keyword">int</span> lastkey;  <span class="comment">/* The last argument that's a key */</span></span><br><span class="line">    <span class="keyword">int</span> keystep;  <span class="comment">/* The step between first and last key */</span></span><br><span class="line">    <span class="comment">// 统计信息</span></span><br><span class="line">    <span class="comment">// microseconds 记录了命令执行耗费的总毫微秒数</span></span><br><span class="line">    <span class="comment">// calls 是命令被执行的总次数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> microseconds, calls;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>这里以<strong>setCommand</strong>为例说明</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(redisClient *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    setGenericCommand(c,flags,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>],expire,unit,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGenericCommand</span><span class="params">(redisClient *c, <span class="keyword">int</span> flags, robj *key, </span></span></span><br><span class="line"><span class="function"><span class="params">    robj *val, robj *expire, <span class="keyword">int</span> unit, robj *ok_reply, </span></span></span><br><span class="line"><span class="function"><span class="params">    robj *abort_reply)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    setKey(c-&gt;db,key,val);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 关键代码，将resp写回client(epoll注册写事件，ready后内核向cfd写回数据)</span></span><br><span class="line">    addReply(c, ok_reply ? ok_reply : shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setKey</span><span class="params">(redisDb *db, robj *key, robj *val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lookupKeyWrite(db,key) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        dbAdd(db,key,val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dbOverwrite(db,key,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// setKey() 首先查看 key 是否存在于数据集中，如果存在则覆盖写；如果不存在则添加到数据集中。这里关注 key 不存在的情况：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbAdd</span><span class="params">(redisDb *db, robj *key, robj *val)</span> </span>&#123;</span><br><span class="line">    sds copy = sdsdup(key-&gt;ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//dictAdd() 把key存到字典哈希表中。</span></span><br><span class="line">    <span class="keyword">int</span> retval = dictAdd(db-&gt;dict, copy, val);</span><br><span class="line"></span><br><span class="line">    redisAssertWithInfo(<span class="literal">NULL</span>,key,retval == REDIS_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>addReply</strong>函数: 首先调用<strong>prepareClientToWrite(c)</strong>函数注册写事，即aeCreateFileEvent(server.el, c-&gt;fd, AE_WRITABLE, sendReplyToClient, c)；再将写回的内容添加至client结构的buf缓冲区c-&gt;buf。待再一次回到事件循环的时候，如果这个套接字可写，相应的回调函数就可以被回调了，回复缓存中的数据会被发送到客户端。</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addReply</span><span class="params">(redisClient *c, robj *obj)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为客户端安装写处理器到事件循环</span></span><br><span class="line">    <span class="keyword">if</span> (prepareClientToWrite(c) != REDIS_OK) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is an important place where we can avoid copy-on-write</span></span><br><span class="line"><span class="comment">     * when there is a saving child running, avoiding touching the</span></span><br><span class="line"><span class="comment">     * refcount field of the object if it's not needed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果在使用子进程，那么尽可能地避免修改对象的 refcount 域。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the encoding is RAW and there is room in the static buffer</span></span><br><span class="line"><span class="comment">     * we'll be able to send the object to the client without</span></span><br><span class="line"><span class="comment">     * messing with its page. </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果对象的编码为 RAW ，并且静态缓冲区中有空间</span></span><br><span class="line"><span class="comment">     * 那么就可以在不弄乱内存页的情况下，将对象发送给客户端。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (sdsEncodedObject(obj)) &#123;</span><br><span class="line">        <span class="comment">// 首先尝试复制内容到 c-&gt;buf 中，这样可以避免内存分配</span></span><br><span class="line">        <span class="keyword">if</span> (_addReplyToBuffer(c,obj-&gt;ptr,sdslen(obj-&gt;ptr)) != REDIS_OK)</span><br><span class="line">            <span class="comment">// 如果 c-&gt;buf 中的空间不够，就复制到 c-&gt;reply 链表中</span></span><br><span class="line">            <span class="comment">// 可能会引起内存分配</span></span><br><span class="line">            _addReplyObjectToList(c,obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;encoding == REDIS_ENCODING_INT) &#123;</span><br><span class="line">        <span class="comment">/* Optimization: if there is room in the static buffer for 32 bytes</span></span><br><span class="line"><span class="comment">         * (more than the max chars a 64 bit integer can take as string) we</span></span><br><span class="line"><span class="comment">         * avoid decoding the object and go for the lower level approach. */</span></span><br><span class="line">        <span class="comment">// 优化，如果 c-&gt;buf 中有等于或多于 32 个字节的空间</span></span><br><span class="line">        <span class="comment">// 那么将整数直接以字符串的形式复制到 c-&gt;buf 中</span></span><br><span class="line">        <span class="keyword">if</span> (listLength(c-&gt;reply) == <span class="number">0</span> &amp;&amp; (<span class="keyword">sizeof</span>(c-&gt;buf) - c-&gt;bufpos) &gt;= <span class="number">32</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">            len = ll2string(buf,<span class="keyword">sizeof</span>(buf),(<span class="keyword">long</span>)obj-&gt;ptr);</span><br><span class="line">            <span class="keyword">if</span> (_addReplyToBuffer(c,buf,len) == REDIS_OK)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">/* else... continue with the normal code path, but should never</span></span><br><span class="line"><span class="comment">             * happen actually since we verified there is room. */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行到这里，代表对象是整数，并且长度大于 32 位</span></span><br><span class="line">        <span class="comment">// 将它转换为字符串</span></span><br><span class="line">        obj = getDecodedObject(obj);</span><br><span class="line">        <span class="comment">// 保存到缓存中</span></span><br><span class="line">        <span class="keyword">if</span> (_addReplyToBuffer(c,obj-&gt;ptr,sdslen(obj-&gt;ptr)) != REDIS_OK)</span><br><span class="line">            _addReplyObjectToList(c,obj);</span><br><span class="line">        decrRefCount(obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">"Wrong obj-&gt;encoding in addReply()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="aeMain函数跟踪"><a href="#aeMain函数跟踪" class="headerlink" title="aeMain函数跟踪"></a><strong>aeMain</strong>函数跟踪</h2>   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">aeMain(server.el); <span class="comment">// 循环监听事件 while(!stop)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进入事件循环可能会进入睡眠状态。在睡眠之前，执行预设置的函数 aeSetBeforeSleepProc()。</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// AE_ALL_EVENTS 表示处理所有的事件</span></span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>aeProcessEvents</strong>函数: Process every pending time event, then every pending file event. Without special flags the function sleeps until some file event fires, or when the next time event occurs (if any). If flags is 0, the function does nothing and returns. if flags has AE_ALL_EVENTS set, all the kind of events are processed. if flags has AE_FILE_EVENTS set, file events are processed.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">aeProcessEvents(eventLoop, AE_ALL_EVENTS);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nothing to do? return ASAP */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note that we want call select() even if there are no</span></span><br><span class="line"><span class="comment">     * file events to process as long as we want to process time</span></span><br><span class="line"><span class="comment">     * events, in order to sleep until the next time event is ready</span></span><br><span class="line"><span class="comment">     * to fire. */</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</span><br><span class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        aeTimeEvent *shortest = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>, *<span class="title">tvp</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取最近的时间事件</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</span><br><span class="line">            shortest = aeSearchNearestTimer(eventLoop);</span><br><span class="line">        <span class="keyword">if</span> (shortest) &#123;</span><br><span class="line">            <span class="comment">// 如果时间事件存在的话</span></span><br><span class="line">            <span class="comment">// 那么根据最近可执行时间事件和现在时间的时间差来决定文件事件的阻塞时间</span></span><br><span class="line">            <span class="keyword">long</span> now_sec, now_ms;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Calculate the time missing for the nearest</span></span><br><span class="line"><span class="comment">             * timer to fire. */</span></span><br><span class="line">            <span class="comment">// 计算距今最近的时间事件还要多久才能达到</span></span><br><span class="line">            <span class="comment">// 并将该时间距保存在 tv 结构中</span></span><br><span class="line">            aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line">            tvp-&gt;tv_sec = shortest-&gt;when_sec - now_sec;</span><br><span class="line">            <span class="keyword">if</span> (shortest-&gt;when_ms &lt; now_ms) &#123;</span><br><span class="line">                tvp-&gt;tv_usec = ((shortest-&gt;when_ms+<span class="number">1000</span>) - now_ms)*<span class="number">1000</span>;</span><br><span class="line">                tvp-&gt;tv_sec --;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tvp-&gt;tv_usec = (shortest-&gt;when_ms - now_ms)*<span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 时间差小于 0 ，说明事件已经可以执行了，将秒和毫秒设为 0 （不阻塞）</span></span><br><span class="line">            <span class="keyword">if</span> (tvp-&gt;tv_sec &lt; <span class="number">0</span>) tvp-&gt;tv_sec = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (tvp-&gt;tv_usec &lt; <span class="number">0</span>) tvp-&gt;tv_usec = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 执行到这一步，说明没有时间事件</span></span><br><span class="line">            <span class="comment">// 那么根据 AE_DONT_WAIT 是否设置来决定是否阻塞，以及阻塞的时间长度</span></span><br><span class="line">            <span class="comment">/* If we have to check for events but need to return</span></span><br><span class="line"><span class="comment">             * ASAP because of AE_DONT_WAIT we need to set the timeout</span></span><br><span class="line"><span class="comment">             * to zero */</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">                <span class="comment">// 设置文件事件不阻塞</span></span><br><span class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">                tvp = &amp;tv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Otherwise we can block */</span></span><br><span class="line">                <span class="comment">// 文件事件可以阻塞直到有事件到达为止</span></span><br><span class="line">                tvp = <span class="literal">NULL</span>; <span class="comment">/* wait forever */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关键调用，处理文件事件，阻塞时间由 tvp 决定</span></span><br><span class="line">        numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            <span class="comment">// 从已就绪数组中获取事件</span></span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="keyword">int</span> rfired = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           	<span class="comment">/* note the fe-&gt;mask &amp; mask &amp; ... code: maybe an already processed</span></span><br><span class="line"><span class="comment">             * event removed an element that fired and we still didn't</span></span><br><span class="line"><span class="comment">             * processed, so we check if the event is still valid. */</span></span><br><span class="line">            <span class="comment">// Reactor模型的精髓所在:</span></span><br><span class="line">            <span class="comment">// 读事件，执行对应回调函数</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                <span class="comment">// rfired 确保读/写事件只能执行其中一个</span></span><br><span class="line">                rfired = <span class="number">1</span>;</span><br><span class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 写事件，执行对应回调函数</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rfired || fe-&gt;wfileProc != fe-&gt;rfileProc)</span><br><span class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check time events */</span></span><br><span class="line">    <span class="comment">// 执行时间事件</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        processed += processTimeEvents(eventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed; <span class="comment">/* return the number of processed file/time events */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>aeApiPoll</strong>函数:    </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, struct timeval *tvp)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="keyword">int</span> retval, numevents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键调用，多路复用监听</span></span><br><span class="line">    retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,</span><br><span class="line">            tvp ? (tvp-&gt;tv_sec*<span class="number">1000</span> + tvp-&gt;tv_usec/<span class="number">1000</span>) : <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有至少一个事件就绪？</span></span><br><span class="line">    <span class="keyword">if</span> (retval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="comment">// 为已就绪事件设置相应的模式</span></span><br><span class="line">        <span class="comment">// 并加入到 eventLoop 的 fired 数组中</span></span><br><span class="line">        numevents = retval;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">e</span> = <span class="title">state</span>-&gt;<span class="title">events</span>+<span class="title">j</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE;</span><br><span class="line"></span><br><span class="line">            eventLoop-&gt;fired[j].fd = e-&gt;data.fd;</span><br><span class="line">            eventLoop-&gt;fired[j].mask = mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回已就绪事件个数</span></span><br><span class="line">    <span class="keyword">return</span> numevents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote><p>至此，有关Redis是如何利用Epoll的Reactor模型提供网络服务的流程概述已经梳理了一遍，本文结束。</p>
</blockquote></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Xiaoru Zhu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://kevin-chu.com/2021/04/23/blog8/">http://kevin-chu.com/2021/04/23/blog8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/C-C/">C/C++</a><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2018/04/11/blog7/"><span>vim配置--高亮+自动缩进+行号+折叠+python补全</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/images/sunset.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2021 By Xiaoru Zhu</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>